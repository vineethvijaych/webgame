<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline'; object-src 'none';"
    />
    <title>SketchJump AR - 2D + AR Pencil-Sketch Platformer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Courier New', monospace;
        background: linear-gradient(45deg, #f5f5dc, #e8e8e8);
        background-image: radial-gradient(
            circle at 25% 25%,
            rgba(0, 0, 0, 0.02) 1px,
            transparent 1px
          ),
          radial-gradient(
            circle at 75% 75%,
            rgba(0, 0, 0, 0.02) 1px,
            transparent 1px
          );
        background-size: 20px 20px;
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        user-select: none;
        touch-action: none;
        position: fixed;
        top: 0;
        left: 0;
      }

      .game-container {
        display: flex;
        height: 100vh;
        width: 100vw;
        position: relative;
        flex-direction: row;
      }

      .game-side {
        flex: 1;
        position: relative;
        border: 2px solid #333;
        border-radius: 8px;
        margin: 5px 2px;
        overflow: hidden;
        background: #fafafa;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
        min-height: 0;
      }

      .game-side::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: linear-gradient(
            90deg,
            rgba(0, 0, 0, 0.02) 1px,
            transparent 1px
          ),
          linear-gradient(rgba(0, 0, 0, 0.02) 1px, transparent 1px);
        background-size: 30px 30px;
        pointer-events: none;
        z-index: 1;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
        z-index: 2;
      }

      .ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 10;
      }

      .score-display {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border: 2px solid #333;
        border-radius: 20px;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .lives-display {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 15px;
        border: 2px solid #333;
        border-radius: 15px;
        font-size: 16px;
        font-weight: bold;
      }

      .controls {
        position: absolute;
        bottom: 10px;
        pointer-events: auto;
        z-index: 20;
      }

      .joystick {
        left: 15px;
        width: 80px;
        height: 80px;
        background: rgba(255, 255, 255, 0.95);
        border: 3px solid #333;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        touch-action: none;
        user-select: none;
      }

      .joystick-knob {
        width: 25px;
        height: 25px;
        background: #333;
        border-radius: 50%;
        transition: transform 0.05s;
        pointer-events: none;
      }

      .jump-button {
        right: 15px;
        width: 80px;
        height: 80px;
        background: rgba(255, 100, 100, 0.95);
        border: 3px solid #333;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 24px;
        font-weight: bold;
        color: #333;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        transition: transform 0.1s;
        touch-action: none;
        user-select: none;
      }

      .jump-button:active {
        transform: scale(0.9);
      }

      .side-label {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: bold;
      }

      .camera-status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 10px;
        font-size: 10px;
      }

      .instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border: 3px solid #333;
        border-radius: 15px;
        text-align: center;
        max-width: 300px;
        z-index: 100;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      }

      .instructions h3 {
        margin-bottom: 10px;
        color: #333;
      }

      .instructions p {
        margin-bottom: 8px;
        font-size: 14px;
        color: #666;
      }

      .start-button {
        background: #4caf50;
        color: white;
        border: 2px solid #333;
        padding: 10px 20px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        margin-top: 10px;
        transition: background 0.2s;
      }

      .start-button:hover {
        background: #45a049;
      }

      /* Force landscape orientation for mobile */
      @media screen and (orientation: portrait) {
        body::before {
          content: 'Please rotate your device to landscape mode for the best experience';
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.9);
          color: white;
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          z-index: 1000;
          font-size: 16px;
        }
      }

      @media (max-height: 500px) {
        .score-display,
        .lives-display {
          top: 5px;
          font-size: 14px;
          padding: 5px 10px;
        }

        .side-label {
          font-size: 10px;
          padding: 3px 6px;
        }

        .camera-status {
          font-size: 8px;
          padding: 3px 6px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- 2D Game Side -->
      <div class="game-side">
        <div class="side-label">2D World</div>
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- AR Camera Side -->
      <div class="game-side">
        <div class="side-label">AR World</div>
        <canvas id="arCanvas"></canvas>
        <div class="camera-status" id="cameraStatus">
          Initializing camera...
        </div>
      </div>

      <!-- UI Overlay -->
      <div class="ui-overlay">
        <div class="score-display">Score: <span id="score">0</span></div>
        <div class="lives-display">‚ù§Ô∏è <span id="lives">3</span></div>

        <!-- Touch Controls -->
        <div class="controls joystick" id="joystick">
          <div class="joystick-knob" id="joystickKnob"></div>
        </div>
        <div class="controls jump-button" id="jumpButton">‚Üë</div>
      </div>

      <!-- Instructions Modal -->
      <div class="instructions" id="instructions">
        <h3>üéÆ SketchJump AR</h3>
        <p>‚Ä¢ Move with WASD or touch joystick</p>
        <p>‚Ä¢ Jump with SPACE or jump button</p>
        <p>‚Ä¢ Cross between 2D and AR worlds</p>
        <p>‚Ä¢ Stand on real objects in AR side</p>
        <p>‚Ä¢ Earn points for successful jumps!</p>
        <button class="start-button" id="startButton">Start Game</button>
      </div>
    </div>

    <script>
      // Game Engine Core
      class GameEngine {
        constructor() {
          this.gameCanvas = document.getElementById('gameCanvas');
          this.arCanvas = document.getElementById('arCanvas');
          this.gameCtx = this.gameCanvas.getContext('2d');
          this.arCtx = this.arCanvas.getContext('2d');

          this.score = 0;
          this.lives = 3;
          this.gameStarted = false;
          this.lastTime = 0;

          this.keys = {};
          this.joystickActive = false;
          this.joystickDirection = { x: 0, y: 0 };

          this.setupCanvases();
          this.setupControls();
          this.setupPlayer();
          this.setupPlatforms();
          this.setupAR();

          this.particles = [];

          document
            .getElementById('startButton')
            .addEventListener('click', () => {
              this.startGame();
            });

          this.updateUI();
        }

        setupCanvases() {
          const resizeCanvases = () => {
            try {
              const container = document.querySelector('.game-container');
              if (!container) return;

              const containerRect = container.getBoundingClientRect();
              const sideWidth = Math.floor((containerRect.width - 20) / 2);
              const sideHeight = Math.floor(containerRect.height - 20);

              if (sideWidth > 0 && sideHeight > 0) {
                this.gameCanvas.width = sideWidth;
                this.gameCanvas.height = sideHeight;
                this.arCanvas.width = sideWidth;
                this.arCanvas.height = sideHeight;
              }
            } catch (error) {
              console.log('Canvas resize error:', error);
            }
          };

          // Initial setup with delay
          setTimeout(resizeCanvases, 100);

          window.addEventListener('resize', () => {
            setTimeout(resizeCanvases, 100);
          });

          window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvases, 500);
          });
        }

        setupControls() {
          // Keyboard controls
          document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (e.code === 'Space') {
              e.preventDefault();
              if (this.gameStarted && this.player) {
                this.player.jump();
              }
            }
          });

          document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
          });

          // Touch joystick
          const joystick = document.getElementById('joystick');
          const joystickKnob = document.getElementById('joystickKnob');

          const handleJoystickStart = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.joystickActive = true;
            joystick.style.transform = 'scale(1.1)';
          };

          const handleJoystickMove = (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            e.stopPropagation();

            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 25;

            if (distance <= maxDistance) {
              this.joystickDirection.x = deltaX / maxDistance;
              this.joystickDirection.y = deltaY / maxDistance;
              joystickKnob.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            } else {
              const angle = Math.atan2(deltaY, deltaX);
              this.joystickDirection.x = Math.cos(angle);
              this.joystickDirection.y = Math.sin(angle);
              joystickKnob.style.transform = `translate(${
                Math.cos(angle) * maxDistance
              }px, ${Math.sin(angle) * maxDistance}px)`;
            }
          };

          const handleJoystickEnd = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.joystickActive = false;
            this.joystickDirection = { x: 0, y: 0 };
            joystickKnob.style.transform = 'translate(0px, 0px)';
            joystick.style.transform = 'scale(1)';
          };

          joystick.addEventListener('mousedown', handleJoystickStart);
          joystick.addEventListener('touchstart', handleJoystickStart);
          document.addEventListener('mousemove', handleJoystickMove);
          document.addEventListener('touchmove', handleJoystickMove);
          document.addEventListener('mouseup', handleJoystickEnd);
          document.addEventListener('touchend', handleJoystickEnd);

          // Jump button
          const jumpButton = document.getElementById('jumpButton');

          const handleJump = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (this.gameStarted && this.player) {
              this.player.jump();
            }
          };

          jumpButton.addEventListener('touchstart', handleJump);
          jumpButton.addEventListener('mousedown', handleJump);
        }

        setupPlayer() {
          this.player = {
            x: 100,
            y: 300,
            width: 30,
            height: 40,
            vx: 0,
            vy: 0,
            onGround: false,
            canDoubleJump: true,
            side: 'left', // 'left' or 'right'
            animFrame: 0,
            animTime: 0,

            jump() {
              if (this.onGround) {
                this.vy = -12;
                this.onGround = false;
                this.canDoubleJump = true;
                game.addParticles(
                  this.x + this.width / 2,
                  this.y + this.height,
                  'jump',
                );
              } else if (this.canDoubleJump) {
                this.vy = -10;
                this.canDoubleJump = false;
                game.addParticles(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  'doubleJump',
                );
              }
            },

            update(deltaTime) {
              // Handle input
              let moveX = 0;
              if (
                game.keys['KeyA'] ||
                game.keys['ArrowLeft'] ||
                game.joystickDirection.x < -0.3
              ) {
                moveX = -1;
              }
              if (
                game.keys['KeyD'] ||
                game.keys['ArrowRight'] ||
                game.joystickDirection.x > 0.3
              ) {
                moveX = 1;
              }

              // Apply movement
              this.vx = moveX * 5;

              // Apply gravity
              this.vy += 0.5;
              if (this.vy > 15) this.vy = 15;

              // Update position
              this.x += this.vx;
              this.y += this.vy;

              // Determine which side player is on
              const gameWidth = game.gameCanvas.width || 400;

              if (this.x + this.width / 2 < gameWidth) {
                this.side = 'left';
              } else {
                this.side = 'right';
              }

              // Handle collisions
              this.handleCollisions();

              // Update animation
              this.animTime += deltaTime;
              if (this.animTime > 200) {
                this.animFrame = (this.animFrame + 1) % 4;
                this.animTime = 0;
              }

              // Check for side crossing bonus
              if (
                this.side === 'right' &&
                this.onGround &&
                game.arPlatforms.length > 0
              ) {
                // Check if standing on AR platform
                for (let platform of game.arPlatforms) {
                  if (
                    this.x < platform.x + platform.width &&
                    this.x + this.width > platform.x &&
                    this.y + this.height >= platform.y - 5 &&
                    this.y + this.height <= platform.y + 5
                  ) {
                    game.addScore(5);
                    break;
                  }
                }
              }
            },

            handleCollisions() {
              const gameHeight = game.gameCanvas.height || 600;
              const arHeight = game.arCanvas.height || 600;
              const gameWidth = game.gameCanvas.width || 400;

              // Ground collision
              if (this.side === 'left') {
                if (this.y + this.height >= gameHeight - 50) {
                  this.y = gameHeight - 50 - this.height;
                  this.vy = 0;
                  this.onGround = true;
                }

                // Platform collisions for 2D side
                for (let platform of game.platforms) {
                  if (
                    this.x < platform.x + platform.width &&
                    this.x + this.width > platform.x &&
                    this.y + this.height > platform.y &&
                    this.y < platform.y + platform.height
                  ) {
                    if (this.vy > 0 && this.y < platform.y) {
                      this.y = platform.y - this.height;
                      this.vy = 0;
                      this.onGround = true;
                      game.addParticles(
                        this.x + this.width / 2,
                        this.y + this.height,
                        'land',
                      );
                    }
                  }
                }
              } else {
                if (this.y + this.height >= arHeight - 50) {
                  this.y = arHeight - 50 - this.height;
                  this.vy = 0;
                  this.onGround = true;
                }

                // AR platform collisions
                for (let platform of game.arPlatforms) {
                  if (
                    this.x < platform.x + platform.width &&
                    this.x + this.width > platform.x &&
                    this.y + this.height > platform.y &&
                    this.y < platform.y + platform.height
                  ) {
                    if (this.vy > 0 && this.y < platform.y) {
                      this.y = platform.y - this.height;
                      this.vy = 0;
                      this.onGround = true;
                      game.addParticles(
                        this.x + this.width / 2,
                        this.y + this.height,
                        'land',
                      );
                      game.addScore(10);
                    }
                  }
                }
              }

              // Boundary checks
              const totalWidth = gameWidth + (game.arCanvas.width || 400);

              if (this.x < 0) this.x = 0;
              if (this.x + this.width > totalWidth) {
                this.x = totalWidth - this.width;
              }

              // Death check
              if (this.y > Math.max(gameHeight, arHeight) + 100) {
                this.respawn();
              }
            },

            respawn() {
              this.x = 100;
              this.y = 300;
              this.vx = 0;
              this.vy = 0;
              this.side = 'left';
              game.lives--;
              game.updateUI();

              if (game.lives <= 0) {
                game.gameOver();
              }
            },

            draw(ctx, offsetX = 0) {
              ctx.save();

              // Draw sketch-style character
              ctx.strokeStyle = '#333';
              ctx.lineWidth = 2;
              ctx.fillStyle = '#f0f0f0';

              const drawX = this.x - offsetX;

              // Body
              ctx.fillRect(drawX + 8, this.y + 10, 14, 20);
              ctx.strokeRect(drawX + 8, this.y + 10, 14, 20);

              // Head
              ctx.beginPath();
              ctx.arc(drawX + 15, this.y + 8, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();

              // Eyes
              ctx.fillStyle = '#333';
              ctx.fillRect(drawX + 12, this.y + 6, 2, 2);
              ctx.fillRect(drawX + 16, this.y + 6, 2, 2);

              // Legs (animated)
              const legOffset = Math.sin(this.animFrame * 0.5) * 3;
              ctx.strokeRect(drawX + 10, this.y + 30, 4, 10 + legOffset);
              ctx.strokeRect(drawX + 16, this.y + 30, 4, 10 - legOffset);

              // Arms
              ctx.strokeRect(drawX + 4, this.y + 15, 4, 8);
              ctx.strokeRect(drawX + 22, this.y + 15, 4, 8);

              ctx.restore();
            },
          };
        }

        setupPlatforms() {
          this.platforms = [
            { x: 200, y: 350, width: 100, height: 20 },
            { x: 350, y: 280, width: 80, height: 20 },
            { x: 150, y: 200, width: 120, height: 20 },
            { x: 320, y: 150, width: 90, height: 20 },
          ];

          this.arPlatforms = [];
        }

        setupAR() {
          this.cameraActive = false;
          this.setupFallbackAR(); // Start with fallback

          // Try to initialize camera
          this.initCamera().catch((err) => {
            console.log('Camera initialization failed:', err);
            document.getElementById('cameraStatus').textContent =
              'Camera unavailable - using fallback';
          });
        }

        async initCamera() {
          try {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                  width: { ideal: 320 },
                  height: { ideal: 240 },
                  facingMode: 'environment',
                },
              });

              this.video = document.createElement('video');
              this.video.srcObject = stream;
              this.video.width = 320;
              this.video.height = 240;
              this.video.autoplay = true;
              this.video.muted = true;

              this.sketchCanvas = document.createElement('canvas');
              this.sketchCtx = this.sketchCanvas.getContext('2d');

              this.video.onloadedmetadata = () => {
                this.cameraActive = true;
                document.getElementById('cameraStatus').textContent =
                  'Camera active';
              };
            } else {
              throw new Error('getUserMedia not supported');
            }
          } catch (err) {
            console.log('Camera not available:', err);
            document.getElementById('cameraStatus').textContent =
              'Camera unavailable - using fallback';
            this.setupFallbackAR();
          }
        }

        setupFallbackAR() {
          // Create fake AR platforms when camera is not available
          this.arPlatforms = [
            { x: 50, y: 200, width: 100, height: 15 },
            { x: 200, y: 150, width: 80, height: 15 },
            { x: 120, y: 300, width: 120, height: 15 },
          ];
        }

        processARFrame() {
          if (!this.cameraActive || !this.video || !this.video.videoWidth) {
            return;
          }

          const canvas = this.sketchCanvas;
          const ctx = this.sketchCtx;

          canvas.width = this.video.videoWidth;
          canvas.height = this.video.videoHeight;

          // Draw video frame
          ctx.drawImage(this.video, 0, 0);

          // Get image data for processing
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Convert to grayscale and apply edge detection
          for (let i = 0; i < data.length; i += 4) {
            const gray =
              data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            data[i] = gray;
            data[i + 1] = gray;
            data[i + 2] = gray;
          }

          ctx.putImageData(imageData, 0, 0);

          // Simple platform detection (horizontal edges)
          this.detectPlatforms(imageData);
        }

        detectPlatforms(imageData) {
          const data = imageData.data;
          const width = imageData.width;
          const height = imageData.height;
          const platforms = [];

          // Simple horizontal edge detection
          for (let y = 50; y < height - 50; y += 20) {
            for (let x = 10; x < width - 50; x += 30) {
              const idx = (y * width + x) * 4;
              const current = data[idx];
              const below = data[((y + 10) * width + x) * 4];

              if (Math.abs(current - below) > 50) {
                // Scale to AR canvas size
                const scaledX = (x / width) * this.arCanvas.width;
                const scaledY = (y / height) * this.arCanvas.height;

                platforms.push({
                  x: scaledX,
                  y: scaledY,
                  width: 60,
                  height: 10,
                });
              }
            }
          }

          // Merge nearby platforms and limit count
          this.arPlatforms = this.mergePlatforms(platforms).slice(0, 5);
        }

        mergePlatforms(platforms) {
          const merged = [];
          const threshold = 50;

          for (let platform of platforms) {
            let found = false;
            for (let existing of merged) {
              if (
                Math.abs(platform.x - existing.x) < threshold &&
                Math.abs(platform.y - existing.y) < threshold
              ) {
                found = true;
                break;
              }
            }
            if (!found) {
              merged.push(platform);
            }
          }

          return merged;
        }

        addParticles(x, y, type) {
          const count = type === 'jump' ? 5 : type === 'land' ? 8 : 3;
          for (let i = 0; i < count; i++) {
            this.particles.push({
              x: x + (Math.random() - 0.5) * 20,
              y: y + (Math.random() - 0.5) * 10,
              vx: (Math.random() - 0.5) * 4,
              vy: Math.random() * -3 - 1,
              life: 1,
              decay: 0.02,
              size: Math.random() * 3 + 1,
              type: type,
            });
          }
        }

        updateParticles(deltaTime) {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity
            p.life -= p.decay;

            if (p.life <= 0) {
              this.particles.splice(i, 1);
            }
          }
        }

        drawParticles(ctx, offsetX = 0) {
          ctx.save();
          for (let p of this.particles) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle =
              p.type === 'jump'
                ? '#4CAF50'
                : p.type === 'land'
                ? '#8B4513'
                : '#FFD700';
            ctx.fillRect(p.x - offsetX, p.y, p.size, p.size);
          }
          ctx.restore();
        }

        addScore(points) {
          this.score += points;
          this.updateUI();
        }

        updateUI() {
          document.getElementById('score').textContent = this.score;
          document.getElementById('lives').textContent = this.lives;
        }

        startGame() {
          document.getElementById('instructions').style.display = 'none';
          this.gameStarted = true;
          this.lastTime = performance.now();
          this.gameLoop();
        }

        gameOver() {
          this.gameStarted = false;
          setTimeout(() => {
            alert(`Game Over! Final Score: ${this.score}`);
            location.reload();
          }, 500);
        }

        gameLoop(currentTime = 0) {
          if (!this.gameStarted) return;

          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;

          // Update game state
          this.player.update(deltaTime);
          this.updateParticles(deltaTime);

          // Process AR frame only occasionally to improve performance
          if (currentTime % 100 < 16) {
            // ~6 times per second
            this.processARFrame();
          }

          // Clear canvases
          this.gameCtx.clearRect(
            0,
            0,
            this.gameCanvas.width,
            this.gameCanvas.height,
          );
          this.arCtx.clearRect(0, 0, this.arCanvas.width, this.arCanvas.height);

          // Draw 2D side
          this.draw2DWorld();

          // Draw AR side
          this.drawARWorld();

          requestAnimationFrame((time) => this.gameLoop(time));
        }

        draw2DWorld() {
          const ctx = this.gameCtx;
          const width = this.gameCanvas.width;
          const height = this.gameCanvas.height;

          // Background
          ctx.fillStyle = '#fafafa';
          ctx.fillRect(0, 0, width, height);

          // Draw sketch-style platforms
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 3;
          ctx.fillStyle = '#e0e0e0';

          for (let platform of this.platforms) {
            // Platform with sketch effect
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height,
            );
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height,
            );

            // Add sketch lines
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(platform.x + i * 20, platform.y + 2);
              ctx.lineTo(
                platform.x + i * 20 + 15,
                platform.y + platform.height - 2,
              );
              ctx.stroke();
            }
          }

          // Ground
          ctx.fillRect(0, height - 50, width, 50);
          ctx.strokeRect(0, height - 50, width, 50);

          // Draw player if on left side
          if (this.player.side === 'left') {
            this.player.draw(ctx);
          }

          // Draw particles
          this.drawParticles(ctx);

          // Transition indicator
          ctx.strokeStyle = '#ff6b6b';
          ctx.lineWidth = 3;
          ctx.setLineDash([10, 5]);
          ctx.beginPath();
          ctx.moveTo(width - 5, 0);
          ctx.lineTo(width - 5, height);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        drawARWorld() {
          const ctx = this.arCtx;
          const width = this.arCanvas.width;
          const height = this.arCanvas.height;

          // Background
          ctx.fillStyle = '#f5f5f5';
          ctx.fillRect(0, 0, width, height);

          // Draw processed camera feed if available
          if (
            this.cameraActive &&
            this.sketchCanvas &&
            this.sketchCanvas.width > 0
          ) {
            ctx.globalAlpha = 0.3;
            ctx.drawImage(this.sketchCanvas, 0, 0, width, height);
            ctx.globalAlpha = 1;
          }

          // Draw AR platforms
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#d0d0d0';

          for (let platform of this.arPlatforms) {
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height,
            );
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height,
            );

            // Sketch effect
            ctx.beginPath();
            for (let i = 0; i < platform.width; i += 10) {
              ctx.moveTo(platform.x + i, platform.y);
              ctx.lineTo(platform.x + i + 5, platform.y + platform.height);
            }
            ctx.stroke();
          }

          // Ground
          ctx.fillRect(0, height - 50, width, 50);
          ctx.strokeRect(0, height - 50, width, 50);

          // Draw player if on right side
          if (this.player.side === 'right') {
            this.player.draw(ctx, this.gameCanvas.width);
          }

          // Draw particles
          this.drawParticles(ctx, this.gameCanvas.width);

          // AR indicator
          ctx.fillStyle = 'rgba(100, 255, 100, 0.2)';
          ctx.fillRect(0, 0, width, height);

          // Transition indicator
          ctx.strokeStyle = '#ff6b6b';
          ctx.lineWidth = 3;
          ctx.setLineDash([10, 5]);
          ctx.beginPath();
          ctx.moveTo(5, 0);
          ctx.lineTo(5, height);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // Initialize game with error handling
      let game;

      function initializeGame() {
        try {
          game = new GameEngine();
          console.log('SketchJump AR initialized successfully');
        } catch (error) {
          console.error('Game initialization error:', error);
          // Retry after a short delay
          setTimeout(initializeGame, 1000);
        }
      }

      // Wait for DOM to be fully loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeGame);
      } else {
        initializeGame();
      }

      window.addEventListener('load', () => {
        if (!game) {
          initializeGame();
        }
      });
    </script>
  </body>
</html>
